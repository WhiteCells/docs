同一个模板生成的不同类型的函数之间没有任何关系。

除了让编译器自动推到模板的形参类型之外，也可以显式指明。

```cpp
template <typename T>
void foo();
```

C++17 之前模板类型 T 必须是可复制或移动才能传递参数，在 C++17 之后可以传递临时纯右值。



### 万能引用

```cpp
template <typename T>
void f(T &&t) {}

int main(int argc, char *argv[])
{
    int a = 10;
    f(a); // a 是左值表达式，f 是 f<int &> 形参类型是 int &
    f<int &>(a);

    int &ra = a;
    f(ra); // ra 是左值表达式，f 是 f<int &> 形参类型是 int &
    f<int &>(ra);

    int &&rra = 1;
    f(rra); // rra 是左值表达式，f 是 f<int &> 形参类型是 int &
    f<int &>(rra);

    f(int {1}); // int {1} 是右值表达式，f 是 f<int &&> 形参类型是 int &&
    f<int &&>(int {1});

    const int ca = 10;
    f(ca);
    f<const int &>(ca);

    const int &cra = 10;
    f(cra);
    f<const int &>(cra);

    const int &&crra = 10;
    f(crra);
    f<const int &>(crra);

    return 0;
}
```

```cpp
template <typename T>
constexpr T &&forward(T &Arg) noexcept
{
    return static_cast<T &&>(Arg);
}

int main(int argc, char *argv[])
{
    int a = 10;
    ::forward<int>(a);    // 返回 int，因为 T 为 int，所以 T && 是 int&&
    ::forward<int &>(a);  // 返回 int &，因为 T 为 int &，所以 T && 是 int &
    ::forward<int &&>(a); // 返回 int &&，因为 T 为 int &&，所以 T && 为 int &&
    return 0;
}
```



### 完美转发

```cpp

```



