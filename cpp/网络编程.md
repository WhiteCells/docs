### socket 函数

```cpp
#include <sys/socket.h>

int socket(int domain, int type, int protocol);
    argument:
        - domain: 通讯的协议家族
            - PF_INET: IPv4 互联网协议族
            - PF_INET6: IPv6 互联网协议族
            - PF_LOCAL: 本地通信协议族
            - PF_PACKET: 内核底层协议族
            - PF_IPX: IPX Novell 协议族
        - type: 数据传输的类型
            - SOCK_STREAM: 面向连接的 socket
                           1. 数据不会丢失
                           2. 数据顺序不会错乱
                           3. 双向通道
            - SOCK_DGRAM: 无连接的 socket
                          1. 数据可能丢失
                          2. 数据的顺序可能错乱
                          3. 传输效率更高
        - protocol: 使用的协议
                    数据传输方式为 SOCK_STREAM 的协议只有 IPPROTO_TCP
                    数据传输方式为 SOCK_DGRAM 的协议只有 IPPROTO_UDP
                    本参数也可以填 0
```

### TCP 和 UDP 区别

TCP 面向连接，通过三次握手建立连接，四次挥手断开连接。

TCP 是可靠的通信方式，通过超时重传、数据校验等方式确保数据无差错，不丢失、不重复并按顺序到达。

TCP 将数据视为字节流，当网络出现波动时，连接可能出现响应延迟。

TCP 只支持点对点通信。

TCP 报文的首部较大，为 20 字节。

TCP 是全双工的可靠信道。

UDP 是无连接的，即发送数据之前不需要建立连接，这种方式为 UDP 带来高效的传输效率，但也导致无法确保数据的发送成功。

UDP 以最大的速率进行传输，但不保证可靠交付，会出现丢失、重复等问题。

UDP 没有拥塞控制，当网络出现拥塞时，发送方不会降低发送率。

UDP 支持一对一，一对多，多对一和多对多的通信。

UDP 报文的首部较小，为 8 字节。

UDP 是不可靠信道。

### TCP 保证自身可靠的方式

**数据分片**：发送端对用户数据进行分片，在接收端进行重组，由 TCP 确定分片的大小并控制分片和重组。

**到达确认**：接收端接受到分片数据时，根据分片的序号向对端回复一个确认包。

**超时重发**：发送方在发送分片后开始计时，若超时却没有收到对端的确认包，将重发分片。

**滑动窗口**：发送方通过滑动窗口的大小来确认应该发送多少字节的数据。如果窗口大小为0，发送方将停止发送数据，直到接收到新的确认使窗口变得非零为止。

**失序处理**：接收端会将接受到的数据重新排序。

**重复处理**：如果传输的分片出现重复，接收端会丢弃重复的数据。

**数据校验**：通过数据的检验和来判断数据在传输过程中是否正确。



### 主机字节序

数据类型占用的内存空间大于 1 字节，CPU 将数据存放在内存中的两种方式：大端序（*big endian*）、小端序（*little endian*）。

**内存地址单位**：在计算机中，内存地址是以字节为单位的，每个地址存储一个字节（8位），这是因为计算机中的最小可寻址单位是一个字节。

**十六进制表示**：在十六进制表示中，每个十六进制数字代表四个二进制位（4位）。因此，一个字节可以由两个十六进制数字表示。例如，十六进制数 0xAB 表示二进制数 10101011，其中 A 对应二进制数的高四位（1010），B 对应二进制数的低四位（1011）。

**内存地址表示**：因此，内存地址通常以十六进制表示，每个地址由两个十六进制数字组成，表示一个字节的地址。例如，0x00000001 表示内存中的第一个字节的地址，0x00000002 表示内存中的第二个字节的地址，依此类推。

假设从内存地址 0x00000001 处开始存储十六进制数 0x12345678
在大端序（Big Endian）中，数据按照原始顺序存储，即最高有效字节存储在最低的内存地址中，因此数据存储顺序如下：

```
address           data
0x00000001        0x12
0x00000002        0x34
0x00000003        0x56
0x00000004        0x78
```

而在小端序（Little Endian）中，数据按照颠倒顺序存储，即最低有效字节存储在最低的内存地址中，因此数据存储顺序如下：

```
address           data
0x00000001        0x78
0x00000002        0x56
0x00000003        0x34
0x00000004        0x12
```

intel CPU 采用小端序方式保存数据。

传输数据的本质是将数据写入文件，字节序在不同的计算机之间传输，可能会出现问题，为了解决这个问题，通常需要在传输过程中进行字节序的转换。

### 网络字节序

为了解决不同字节序的计算机之间传输数据的问题，约定采用网络字节序（大端序）。

C 语言提供四个库函数用于主机字节序和网络字节序之间的转换：

```cpp
uint16_t htons(uint16_t hostshort); // 2 字节
uint32_t htonl(uint32_t hostlong); // 4 字节
uint16_t ntohs(uint16_t netshort);
uint32_t ntohl(uint32_t netlong);
```

h：host

to：转换

n：network

s：short

l：long

###  IP 地址和通讯端口

IPv4 地址用 4 字节的整数存放，通讯端口用 2 字节（0-65535）的整数存放。

