## OOP

### 三大特征

#### 封装

将数据和操作数据的函数组合在一起，并隐藏内部实现细节

#### 继承

允许子类继承父类的特征，从而实现代码的复用和层次结构

#### 多态

多态主要通过虚函数实现，即同一个接口可以有不同的是实现。

> 运行时多态是在程序执行时动态确定函数调用，依赖于虚函数。
>
> 编译时多态是在编译期间静态确定函数调用的，依赖于重载和模板。

### 构造函数和析构函数

构造函数用于初始化对象，析构函数用于销毁对象。

构造函数可以重载，构造函数分为默认构造、拷贝构造和移动构造。

构造函数只会调用一种，调用含参构造就不会调用默认构造。

析构函数不可以重载。

### 虚函数表

虚函数表是 C++ 实现多态的机制，每一个包含虚函数的类都有一个虚函数表，它是一个函数指针数组，当通过基类指针或引用调用虚函数时，程序会在对象的虚函数表中查找正确的函数地址并调用。

虚函数表指针是存储在对象中的指针，指向对象类的虚函数表，每一个包含虚函数的类的对象都会有一个虚函数表指针，由编译器负责管理。

### 纯虚函数

`virtual void func() = 0`，纯虚函数是特殊的虚函数，在基类中不能对虚函数给出实现，将其声明为纯虚函数，将实现交给派生类去完成。当基类纯虚函数被存在实现，则将不再是纯虚函数。

### 虚析构函数

基类的析构函数建议使用虚函数，避免资源泄漏，派生类可能拥有基类中未定义的资源，如果基类的析构函数不是虚函数，当通过基类指针删除派生类对象时，只会调用基类的析构函数，而不会调用派生类的析构函数。

### 虚继承

### 抽象类

含有纯虚函数的类。

### 接口类

仅含有纯虚函数的类。

### 聚合类

- 所有成员都是 public
- 没有定义任何构造函数
- 没有类内初始化
- 没有基类和虚函数

### 拷贝构造函数必须是 const &

拷贝构造函数是为了复制对象，而不是修改需要被拷贝的对象，所以通过 const 修饰以防止对被拷贝对象的修改。

const & 可以接受的参数类型范围更大，可以接受左值或右值。

引用是为防止无限递归，如果拷贝构造使用传值的方式，每次调用拷贝构造函数时，都会创建一个新的临时对象，这个新的临时对象又需要调用构造函数来创建它的副本，从而导致无限递归。

### 构造函数的 using 声明

C++11 中，派生类能够重用基类定义的构造函数。

### 常用设计模式

- 单例设计模式：
- 工厂设计模式：
- 观察者模式：
- 策略模式：
- 模板方法设计模式：

### 组合和继承

组合是 **has-a** 关系，包含组件类的对象作为成员。

继承是 **is-a** 关系，继承父类的属性和方法。

继承的缺点：

- 子类和父类耦合度高，父类的修改可能影响子类
- 多层继承可能出现复杂的继承体系，难以维护

### this 指针

`this` 指针是隐含于非静态成员函数中的特殊指针，指向调用该成员函数的对象。编译器始终假设 `this` 指针是有效的，即指向某个对象。所以在非静态成员函数内部对 `this` 指针进行检查是冗余操作。应该在使用对象时检查对象的有效性。

当对象调用成员函数时，先将对象的地址赋值给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。

`this` 指针是一个右值，所以不能取地址。

## C

### 字符串结束的标志

字符串以 `\0` 结尾，占一个字节。

### 数组名何时会退化为指针

1. 作为函数参数传递时
2. 用于取地址符时

> 用于 `sizeof` 时不会退化为指针，会返回整个数组的大小。 

### 预处理指令

#### #define

用于定义宏，可以是简单的文本替换，也可以时带参数的复杂替换。编译器会在**预处理阶段**将代码中的宏名替换为宏定义的内容。

`#define SQUARE(x) ((x) * (x))`

**使用场景**：

1. 减少重复代码
2. 提高代码的可维护性
3. 提高代码的可读性，避免代码中的魔法数字（魔数）

**注意事项**：

1. **括号**：在定义带参的宏时，使用括号可以避免替换过程中出现意外的运算符优先级问题：

   ```c
   #define ADD(x, y) ((x) + (y))
   ```

2. **多次求值**：带参数的宏可能会导致参数被多次求值，产生副作用：

   ```c
   #define INCREASING(x) ((x) + (x))
   int i = 0;
   int x = INCREASING(i++); // i 自增两次
   ```

#### #ifdef

检查某个宏是否已经被定义，如果已定义，则编译 `#ifdef` 和对应 `#endif` 之间的代码。

#### #ifndef

检查某个宏是否未定义，如果未定义，则编译 `#ifndef` 和对应的 `#endif` 之间的代码。

#### #endif

用于结束 `#ifdef` 或 `#ifndef` 块。

#### #if 和 #elif

用于复杂的条件编译，支持表达式

#### #else

用于在条件不满足时编译另一个代码块

#### \#pragma pack(n)

设定结构体、联合体及类成员变量以 n 字节方式对齐。

#### #pragma once

防止头文件重复包含。

### 宏

#### assert()

断言，`assert()` 是宏，定义在 `assert.h` 或 `cassert.h`（C++） 中。

如果条件返回错误，则终止程序执行。

可以通过定义宏 `NDEBUG` 来关闭断言。

### 函数传参

函数传参是通过值传递，将一个指针传递给函数，函数收到的是指针的副本，而不是原始指针本身。传入指针只能修改其 `*` 或  `->` 的内容。想要修改指针本身需要传递指针的指针。

### #include "" 与 #include <> 的区别



### 空指针与 0

```c
#include <stdio.h>

void foo(int *) { printf("int *"); }
// void foo(const int *) { printf("const int *"); }

int main(int argc, char *argv[]) {
    foo(0);
    // foo(1);
    return 0;
}
```

## C++

### 字符串

`std::string` 的 `data()` 返回指向字符串首字符的指针，`c_str()` 返回字符串的不可修改的标准 C 字符数组版本。

### int 占 4 个字节与操作系统无关

### \#pragma once 和 include guard 的区别

`#pragma once`

1. 简洁
2. 避免头文件保护符号名的冲突
3. 部分编译器能提高编译速度
4. 非 C++ 标准

include guard

1. 符合 C++ 标准
2. 跨平台
3. 需要确保头文件保护符号名的唯一性

### 前置声明的注意事项

当需要知道类型的内存大小时，不能使用前置声明。

### 构造和析构顺序

**继承的构造和析构顺序**

当创建一个派生类（子类）的对象时，类 B 继承类 A，构造函数的调用顺序是：

1. 父类构造（A 构造）
2. 子类构造（B 构造）

当销毁一个派生类对象时，析构函数的调用顺序是：

1. 子类析构（B 析构）
2. 父类析构（A 析构）

**组合的构造和析构顺序**

当一个类包含其他类的对象（即组合关系）时，类 A 包含类 B，构造函数的调用顺序是：

1. B 构造
2. A 构造

当销毁一个包含类的对象时，析构函数的调用顺序是：

1. A 析构
2. B 析构

### C++ 为什么采用先声明后使用的原则？

C++ 采用一遍扫描，顺序执行

解决解决循环引用的问题

### 为什么需要包含警戒

`#include` 可能导致重复定义

### 包含警戒的常见方法

`#ifndef` 或 `#pragma once`

### 函数 overload

具有不同签名的同名函数同时存在，仅返回值不同不允许构成重载。

判断依据：**是否修改实参，都能修改实参则不能重载，形参的可修改性不影响 overload**。

```cpp
void foo(int);              // 不可能修改实参
void foo(int &);            // 可能修改实参
void foo(const int);        // 不可能修改实参
void foo(const int &);      // 不可能修改实参
void foo(int *);            // 可能修改实参
void foo(int *const);       // 可能修改实参
void foo(const int *);      // 不可能修改实参
void foo(const int *const); // 不可能修改实参
```

但是 `foo(int)` 和 `foo(int &)` 是否可以重载取决于实参的常量性，如果实参为 `const`，则只会调用 `foo(int)`。

### 函数缺省值

函数缺省值只能出现在函数最后几个参数上。

函数缺省值和 overload 可能导致编译时的歧义错误。

当定义和声明共有多次时，至多只能指明一次函数缺省值。

### 模板

模板的声明与实现要位于同一文件。

#### 类模板

#### 成员模板

#### 虚模板

### 位域

类可以将非静态成员变量定义为位域，在一个位域中含有一定数量的二进制位，当程序向其他程序或设备传输二进制数据时，通常会用到位域。

位域不能取地址，指针也无法指向类的位域。

位域的类型必须是整形或枚举类型，带符号类型中的位域的行为因具体实现而定。

位域在内存中的布局与机器相关。

### 初始化和赋值

初始化是从无到有；赋值是已存在对象，然后重新给定一个值。

### 指针与引用

引用是对象的别名，引用必须初始化，类的引用类型的成员变量可以不用立即初始化，但必须在类的成员初始化列表中进行初始化。

引用初始化后，就不能引用另一个对象。

指针本身就是对象，存储另一个对象的内存地址。

不存在引用的引用，存在指针的指针。

指针支持指针运算，引用不可以。

不要返回局部非静态变量的引用或指针。

### 左值引用

基础数据类型大多数情况下，传值比传引用快。

### 运算符

#### 前置递增和后置递增

前置递增先增加后使用，后置递增是先使用后递增。

前置递增的整体是左值，后置递增的整体是右值。

#### :: 范围解析运算符

1. 全局作用域符（`::name`）：表示作用域为全局命名空间。
2. 类作用域符（`class::name`）：用于指定类型定义的作用域范围的类。
3. 命名空间作用域符（`namespace::name`）：用于表示指定类型的作用域范围是具体的某个命名空间。

### 强制类型转换

- `static_cast`：静态强制类型转换，在编译阶段进行类型检查
- `dynamic_cast`：动态强制类型转换，用于安全地进行基类和派生类之间的向上或向下转换
- `reinterpret_cast`：重新解释强制类型转换，用于低级别的强制类型转换，不进行类型检查
- `const_cast`：用于移除或添加 const 属性
- C 风格类型转换：类似于 `static_cast`，但没有明确指定转换的类型

如果基类对象通过 `static_cast`转换为错误的派生类类型，运行时可能会崩溃，应该使用 `dynamic_cast`，在转换失败后会返回空指针。



### 局部静态变量的生命周期

局部静态变量的作用域仅限于声明它的函数内部，不能被其他函数或代码块访问。

当函数第一次被调用时，该变量会被初始化，在后续的调用时不再初始化，直到程序结束才会被销毁。

在多线程环境下，局部静态变量的初始化是线程安全的，可以确保只有一个线程能够完成初始化。（单例设计模式）

### 资源获取即初始化 RAII

RAII（Resource Acquisition Is Initialization）是一种**资源管理策略**（内存、文件句柄、网络连接等）。将资源的生命周期与对象的生命周期绑定在一起，资源的获取和释放都通过**对象的构造和析构来管理**，从而确保资源在对象生命周期结束时自动释放。



### 运行时类型识别 RTTI

RTTI（Run Time Type Identification）允许在运行时获取对象的类型信息。 

C++ 是静态类型语言，通常在编译时类型就已经确定，但在多态情况下，可能需要在运行时确定对象的实际类型。

- dynamic_cast：使用 RTTI 在转换过程中进行类型检查
- typeid：操作符用来获取一个类型的对象的 `std::type_info` 引用。`std::type_info` 类提供了关于类型的信息，如果类型的名字（`name()` 方法）

### 源文件和头文件的类型及区别

源文件：`.cpp`、`.cxx`、`cc`

头文件： `.h`、`.hpp`、`.hxx`

本质没有什么区别

`.cxx` 常用于库文件的源文件

`.hpp` 常用于模板类的声明与实现

### STL

#### std::vector 的底层原理

#### std::vector 的扩容策略

将原有元素复制到新空间，然后释放旧空间，新容量可能是原容量的一定倍数。

#### std::map 与 std::unordered_map 的区别

`std::map` 基于红黑树，保证数据的有序性，`std::unordered_map` 基于哈希表，不保证数据的有序性。

#### std::priority_queue 的底层原理

优先队列，基于堆实现，默认小根堆，按照最小的元素放在顶的顺序存储元素，可以通过谓词来改变排序方式。

#### STL 中支持随机访问的容器

`std::vector`、`std::deque`、`std::array`、`std::string`。

### C++11 特性

#### 智能指针

##### std::enable_shared_from_this 模板类

`std::enable_shared_from_this` 用于安全地获取指向对象本身的 `shared_ptr`，即使该对象已经被 `shared_ptr` 管理。如存在回调等操作时，用于防止对象被提前析构。

使用方法：类需要继承 `std::enable_shared_from_this` 模板类，然后类成员函数中调用 `shared_from_this()` 返回指向对象本身的 `shared_ptr`。

使用 `shared_from_this()` 需要对象构造完成。

##### 智能指针及它们的区别

智能指针是 C++ 标准库中提供的模板类，用于自动管理动态分配的内存。

- `std::unique_ptr`：独占所有权，不可拷贝，只能移动，
- `std::shared_ptr`：共享所有权，可以拷贝和移动，
- `std::weak_ptr`：不拥有所有权，可以拷贝和移动，不影响对象的生命周期，不改变 `use_count`，是一种访问 `std::shared_ptr` 管理的对象的弱引用方式。
- `std::auto_ptr`：C++98 引入，C++11 弃用。其是所有权移动，在复制和赋值操作中会转移所有权，同时其不是线程安全的。

`std::weak_ptr` 和 `std::shared_ptr` 之间的关系是互补的。

`std::weak_ptr` 是一种不增加对象引用计数的弱引用机制，常用于解决循环引用问题。

`std::weak_ptr` 提供了 `expired()`，允许检查其所指向的对象是否不存在（过期）。

`std::weak_ptr` 可以通过 `lock()` 临时转换为 `std::shared_ptr`，`lock()` 会检查 `std::shared_ptr` 指向的对象是否存在。

`std::make_shared` 是专门用于创建 `std::shared_ptr` 的工厂函数，是模板函数，只需一次内存分配，使用了 RAII，直接创建对象并将其管理权交给 `std::shared_ptr`。

`std::make_unique` 类似于 `std::make_shared`，但是其在 C++14 及以上中才支持。

不建议先 `new` 然后在使用 `std::shared_ptr` 的拷贝构造，因为如果 `std::shared_ptr` 发生异常，则 `new` 的内存就不会释放，从而造成内存泄漏。

```cpp
class A {};
std::shared_ptr<A> ptr1 = std::make_shared<A>();

// recommended
std::shared_ptr<A> ptr1 = std::make_shared<A>();

// not recommended
A *ptr_A = new A();
std::shared_ptr<A> ptr2 = std::shared_ptr<A>(ptr_A);
ptr_A = nullptr; // essential, prevent dangling pointers and double release, clarify ownership
```

#### 为什么引入 {} 初始化的方式



#### lambda 表达式

lambda 是匿名可调用对象。

可以用于谓词。lambda 由三个部分组成捕获列表、参数列表和返回类型。

```cpp
#include <iostream>
#include <functional>

int main(int argc, char *argv[]) {

    // error
    // auto factorial = [](int n) {
    //     return n >= 1 ? n * factorial(n - 1) : 1;
    // };

    std::function<int(int)> factorial = [&factorial](int n) -> int {
        return n >= 1 ? n * factorial(n - 1) : 1;
    };

    std::cout << factorial(5) << std::endl;

    return 0;
}
```

如果 lambda 中存在递归行为，则需要显式定义函数类型 `std::function<int(int)>`，并指明返回类型，同时使用捕获列表 `[&factorial]`  捕获 `factorial` 本身，才能使 `lambda` 可以在其主体中递归调用自己。（确保编译器知道 lambda 表达式的完整类型信息）。

捕获列表分为：

- 值捕获：`[=]`
- 引用捕获：`[&]`

#### 右值引用

只能引用右值

#### 引用折叠

| parameter | argument | result |
| --------- | -------- | ------ |
| T &       | &        | T &    |
| T &       | &&       | T &    |
| T &&      | &        | T &    |
| T &&      | &&       | T &&   |

引用折叠发生的情况：模板实例化、`auto` 类型推导、`typedef` 和别名声明、使用 `decltype` 时

#### 完美转发

模板函数在转发参数时保留参数的左值或右值属性，以及 cv 限定符。

完美转发通过通用引用和 `std::forward` 实现，`std::forward` 是一个实现转发的函数模板。

完美转发运用引用折叠规则实现保留参数的原始值类别。

### 类型

#### class 与 struct

成员的默认访问权限不同，struct 默认为 public，class 默认为 private。

默认继承方式不同，struct 默认为 public 继承，class 默认为 private 继承。

#### union 联合体类型

联合（union）是一种节省空间的特殊的类，一个 `union` 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当一个尘缘被赋值后，其他成员为未定义状态。

- 默认访问控制符为 `public`
- 可以有构造函数和析构函数
- 不能有引用类型的成员
- 不能继承其他类，不能作为基类
- 不能有虚函数
- 匿名 union 在定义所在的作用域可直接访问其成员
- 匿名 union 不能有 `protected` 成员或 `private` 成员
- 全局匿名联合必须是静态的

#### enum 枚举类型

不能前置声明

### 运算符

重载 `new` 运算符。

### 关键字

#### new 和 malloc 的区别

- new 是 C++ 的运算符

#### 为什么 C++11 引入 nullptr



#### extern

问题：当 C++ 与 C 混合编程时，在链接时无法找到 C 语言实现的函数。

原因：C 语言函数不能重载，编译时直接使用函数名作为重载，而 C++ 语言中函数可以重载，所以 C++ 编译器需要使用一种机制来区分重载的函数。

解决方法：通过 `extern "C" {}` 告诉编译器在 `{}` 范围内使用 C 语言代码。

`#pragma once` （防卫式声明）是防止头文件重复包含。

`extern` 是分离函数声明和定义，当多个 `.cpp` 文件包含同一个头文件，并且头文件中的函数声明没有使用 `extern`，则会多次定义该函数，从而导致链接错误。

C++ 标准要求每个非内联函数在整个程序中只有一个定义。

在 C++ 中，所有非静态函数的声明默认都是 extern 的。

对于全局变量，extern 不是默认的，所以有时会显式使用 extern 来强调函数和变量声明的区别

#### explicit

`explicit` 用于修饰类的构造函数，防止在调用构造函数时发生隐式类型转换。

#### friend

- 允许访问私有成员
- 破坏的封装性
- 友元关系不可传递
- 友元关系是单向的
- 友元声明的形式及数量不受限制

#### final

修饰虚函数



修饰类



#### mutable

`mutable` 用于修饰类中的成员变量，被修饰成员变量可以在 const 成员函数中被修改。

编译器默认执行 **按位常量性**（bitwise constness），而不是**逻辑常量性**。

#### const

**修饰符**：修饰变量和对象，表明它们的值在初始化之后不能被修改。

**限制符**：限制成员函数，不能修改类的非静态成员变量，也不能调用其他非 const 成员函数，声明为 const  的成员函数保证不会修改对象的状态，因此它可以在 const 对象上被调用。

> **顶层 const**：const 位于 * 左侧，指示指针所指向的对象是不可变的，即不能通过这个指针来修改指向的对象的内容。
>
> **底层 const**：const 位于 * 右侧，指示指针本身是不可变的，即不能指向另一个不同的地址。

#### volatile

`volatile` 用于防止编译器对修饰的对象进行优化。

`volatile` 修饰的变量每次访问都须从内存中取出值，没有被修饰的变量，可能由于编译器优化，从 CPU 寄存器中取值。

`const` 和指针都可以是 `volatile`。

#### static

修饰成员函数，该函数只能访问类中静态成员

修饰成员变量，

修饰全局函数，

修饰全局变量，

#### inline

相当于将内联函数中的内容写在调用该内联函数处。不用执行进入函数的步骤，直接进入函数体，相当于宏，但比宏多了类型检查，编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数。类中实现非虚函数时隐式内联，发生多态的虚函数不能内联，main 函数不能内联。

优点：

- 内联将函数在调用处进行代码展开，省去了参数压栈、栈帧开辟与回收与结果返回等，从而提高程序运行速度。
- 内联函数相对宏函数而言，在代码展开时，会做安全检查或自动类型转换，而宏定义则不会。
- 在类中声明同时定义的成员函数将自动转化为内联函数，内联函数可以访问成员变量，宏定义则不能。
- 内联函数在运行时可调试，宏定义则不可以。

缺点：

- 代码膨胀，内联是以代码膨胀为代价，来消除函数调用带来的开销，每一处内联函数的调用都要复制代码，使得程序的总代码量增大，消耗更多的内存空间。
- 内联函数无法随着函数库升级而升级，内联函数的变化需要重新编译，不像非内联函数可以直接链接。
- 内联的决定权在编译器，内联函数只是对编译器的建议。

#### namespace

`namespace` 可以用于声明命名空间，也可以用于简写命名空间。

```cpp
namespace a {
namespace b {
class X {};
}

namespace c = a::b;
using x = c::X;
```

#### using

- 引入命名空间或其成员。
- C++11 中派生类能够重用其基类定义的构造函数 `using Base::Base;`。
- 使特定的命名空中的所有名字都可见。

> 尽量少用 `using`，以免污染命名空间。

#### typename

在模板编程中，用于指示后面的名称是一个类型名称。

#### decltype

`decltype` 用于检查实体的声明类型或表达式的类型及值分类。

#### delete 与 deletep[]

`delete` 用于释放单个动态分配的对象，`delete[]` 用于释放使用 `new []` 关键字动态分配的数组。

`new []` 与 `delete []` 对应，`new` 与 `delete` 对应。

#### class 与 struct 的区别

`class` 默认访问限定符为 `private`，默认继承的访问限定符也为 `private`，`struct` 默认访问限定符为 `public`，默认继承访问限定符也为 `public`。

#### enum 和 enum class

1. `enum` 没有作用域，在枚举成员定义的作用域内可以直接使用
2. `enum` 是弱类型，可以隐式转换为整数类型，并且可以与整数进行比较
3. `enum`  存在潜在命名冲突，不同的 `enum` 中定义相同的枚举名称，会导致命名冲突

1. `enum class` 定义的枚举类型具有作用域，枚举成员必须通过枚举类型名进行限定
2. `enum class` 是强类型，不允许隐式转换为整数类型，也不允许与其他枚举类型或整数类型进行直接比较
3. `enum class` 避免了枚举成员之间的命名冲突

### 操作符

#### sizeof()

sizeof 对数组，得到整个数组所占空间大小。sizeof 对指针，得到指针本身所占空间大小。

#### alignof()

### 函数

#### strlen()

### 多线程并发

#### 互斥锁与自旋锁

互斥锁（mutex）和自旋锁（spinlock）是两种不同的**同步机制**，在多线程编程中用于控制对共享资源的访问。

互斥锁在获取锁失败时会阻塞线程。适合于持有锁的时间长，可以避免忙等待（忙轮询），阻塞线程节省 CPU 资源，但增加了系统调度和上下文切换的开销。

自旋锁不会阻塞线程，会不断尝试获取锁。适合于持有锁的时间短，且不希望在等待期间让出 CPU 的场景，可以避免切换线程的开销，但会增加 CPU 的使用率。

互斥锁是更通用和安全的选择，自旋锁在高性能计算和实时系统中可以显著提高性能。

#### 介绍线程池

使用 RAII 技术。

线程池是一种多线程处理形式，预先处理一定数量的线程，并加入线程池中，当有任务时，从线程池中取出线程来执行任务，任务完成后线程并不会被销毁，而是返回线程池，等待下一个任务。

创建一个管理线程的类，包含一个固定大小的线程容器，并提供一个任务队列，线程池中的每个线程都在一个循环中等待任务队列中的任务，线程池销毁时，会停止所有线程，并等待线程执行完成。

作用：

- 避免频繁创建和销毁线程的系统开销，提高性能
- 限制并发线程的数量，防止过多的线程同时运行，以免导致系统资源耗尽。

#### 解释 std::future 和 std::promise 是如何协同工作的

`std::promise` 用于线程间传递数据或状态，可以设置一个值或异常。

`std::future` 用于获取由 `std::promise` 设置的值或异常，另一个通过关联的 `std::future` 可以获取到该结果。

一个线程通过 `std::promise` 设置任务完成的状态，另一个线程通过 `std::future` 等待这个标志并进行后续处理。

#### 解释 std::atomic_flag 的特点和用途

`std::atomic_flag` 是最简单的原子类型，只能表示两种状态（设置或清除），用于简单的同步标志。

`std::atomic_flag` 使用 `ATOMIC_FLAG_INIT` 或构造函数初始化，不能使用 `= false` 进行初始化。

```cpp
std::atomic_flag flag1(false);
std::atomic_flag flag2 = ATOMIC_FLAG_INIT;

std::atomic_flag flag3 = false; // error
```

`std::atomic_flag` 对象的方法 `test_and_set()` 返回 true，表明在操作之前对象已是 true，即锁已被其他线程持有。返回 false，表明在执行操作之前对象是 false，即当前线程已经获取锁。

## 网络编程

epoll 是管理 IO，管理客户端是否有数据

LT 水平触发（多次读完）

ET 边缘触发（一次读完）

### TCP

#### TCP 三次握手过程，及发生在哪个函数

1. 连接建立
   1. 三次握手
2. 数据传输
3. 连接断开

#### TCP 四次挥手过程



#### TCP 建立连接为什么需要三次握手，而断开需要四次挥手



#### TIME_WAIT 状态持续时间及原因



#### UDP 并发如何实现



#### TCP 首部长度，及字段



#### TCP 在 listen 时的参数 backlog 的意义



#### accept 发生在三次握手的哪一步



#### 三次握手过程中有哪些不安全性



### UDP

#### UDP 并发如何实现

客户端 `sendto` 服务端 `recvfrom` 然后用心跳包维持连接

### TCP 和 UDP 的区别

TCP 面向字节流，UDP 面向数据报。

## 数据结构

### 单链表



### 双链表



### 循环链表



### 栈



### 队列



### 树



### 堆

堆是一颗完全二叉树，可以使用数组实现堆，堆分为大顶堆和小顶堆。

- 大顶堆：任意父节点的值 $$\ge$$ 其子节点的值，堆顶为最大值
- 小顶堆：任意父节点的值 $$\le$$ 其子节点的值，堆顶为最小值

对于第 i 个节点（i 从 0 开始计数）：

- 父节点：`(i - 1) / 2`
- 左子节点：`2 * i + 1`
- 右子节点：`2 * i + 2`





### 哈希表





### 设计模式



## 架构设计模式

#### MVC

MVC 通过将软件程序分为三个部分（模型、视图、控制器），从而提高代码的**可维护性**、**可拓展性**和**复用性**。

**模型**（Model）

- 负责处理应用程序的数据逻辑
- 表示应用程序的核心功能和数据
- 当模型数据发生变化时，可以通过试图更新显示

**视图**（View）

- 负责数据的显示以及用户界面的呈现
- 从模型获取数据，以友好的方式展示

**控制器**（Controller）

- 负责处理用户输入
- 作为模型和视图之间的桥梁，接收用户的输入，调用模型进行处理，然后将结果更新到试图中

---

32 操作系统和 64 位操作系统区别：

1. **地址空间**
   1. 32 位操作系统：能够寻址最大 4 GB 的内存，实际使用内存会因系统保留和硬件限制而有所减少。
   2. 64 位操作系统：理论上能寻址 16 EB（Exabytes，1 EB = 1024PB）的内存。
2. **性能**
   1. 32 bit：处理器在处理数据时使用 32 位寄存器，可能在处理大型数据时可能性能较差。
   2. 64 bit：处理器在处理数据时使用 64 位寄存器，能处理更多的数据。
3. **兼容性**
   1. 32 bit：只能运行 32 位应用程序
   2. 64 bit：通常可以运行 32 位（兼容层）和 64 位应用程序。
4. **驱动**
5. **安全性**

## 字符编码格式

### ASCII（American Standard Code for Information Interchange）

范围：0～127

特点：仅包含英文字符和一些特殊符号

### ISO-8859 系列

范围：0～255

特点：`ISO-8859-1` 支持法语、德语、西班牙语等，其他系列用于其他语言

### UTF-8（Unicode Transformation Format-8-bit）

范围：1～4 字节表示一个字符

特点：可变长度编码，兼容 `ASCII`，目前互联网应用最广泛的的编码方式

### UTF-16（Unicode Transformation Format-16-bit）

范围：2～4 字节表示一个字符

特点：可变长度编码，适合标识大量的 Unicode 字符

### UTF-32（Unicode Transformation Format-32-bit）

范围：4 字节表示一个字符

特点：固定长度编码，适合完整的 Unicode 集

### GB2312

范围：1～2 字节

特点：用于简体中文字符编码，只覆盖了部分汉字

### GBK（扩展 GB2312）

范围：1～2 字节

特点：扩展 `GB2312`，包含更多的汉字和字符

### GB18030

范围：1～4 字节

特点：兼容 `GBK`，同时支持 Unicode 字符。

### BIG5

范围：1～2 字节

特点：用于繁体中文字符编码

### Shift-JIS（Shift Japanese Industrial Standard）

范围：1～2 字节

特点：用于日文字符编码，兼容 `ASCII`

### EUC-KR（Extended Unix Code for Korean）

范围：1～2 字节

特点：用于韩文字符编码

### Base64

特点：不是字符编码格式，将二进制数据转为 `ASCII` 字符，用于文本传输时避免字符损坏

### Windows-1252

范围：0～255

特点：微软编码标准，用于西欧语言文本编码
