### [1094. 拼车](https://leetcode.cn/problems/car-pooling/)

车上最初有 `capacity` 个空座位。车 **只能** 向一个方向行驶（也就是说，**不允许掉头或改变方向**）

给定整数 `capacity` 和一个数组 `trips` ,  `trip[i] = [numPassengersi, fromi, toi]` 表示第 `i` 次旅行有 `numPassengersi` 乘客，接他们和放他们的位置分别是 `fromi` 和 `toi` 。这些位置是从汽车的初始位置向东的公里数。

当且仅当你可以在所有给定的行程中接送所有乘客时，返回 `true`，否则请返回 `false`。

 

**示例 1：**

```
输入：trips = [[2,1,5],[3,3,7]], capacity = 4
输出：false
```

**示例 2：**

```
输入：trips = [[2,1,5],[3,3,7]], capacity = 5
输出：true
```

 

**提示：**

- `1 <= trips.length <= 1000`
- `trips[i].length == 3`
- `1 <= numPassengersi <= 100`
- `0 <= fromi < toi <= 1000`
- `1 <= capacity <= 10^5`

### 思路

差分

### 代码

```cpp
class Solution {
public:
    bool carPooling(vector<vector<int>> &trips, int capacity) {
        int mx = 0;
        for (const auto &t : trips) {
            mx = max(mx, t[2]);
        }
        vector<int> diff(mx + 1);
        for (const auto &t : trips) {
            diff[t[1]] += t[0];
            diff[t[2]] -= t[0];
        }
        int cur = 0;
        for (int i = 0; i <= mx; ++i) {
            cur += diff[i];
            if (cur > capacity) {
                return false;
            }
        }
        return true;
    }
};
```

```cpp
class Solution {
public:
    bool carPooling(vector<vector<int>> &trips, int capacity) {
        vector<int> site(1001);
        for (const auto &t : trips) {
            int p = t[0], s = t[1], e = t[2];
            for (int i = s; i < e; ++i) {
                site[i] += p;
                if (site[i] > capacity) {
                    return false;
                }
            }
        }
        return true;
    }
};
```

